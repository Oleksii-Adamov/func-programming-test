-- мінімальна кількість видалень це довжина рядка мінус максимальна довжина поліндрома, який є підпослідовністью рядка (lps)
-- lps обраховується рекурсивно
-- Випадок 1: Кожен окремий символ є паліндромом довжиною 1
--        L(i, i) = 1
-- Випадок 2: Якщо є лише 2 символи і вони однакові
--        L(i, j) = 2
-- Випадок 3: Якщо є більше двох символів, і перший і останній символи однакові
--        L(i, j) =  L(i + 1, j – 1) + 2
-- Випадок 4: Якщо перший і останній символи не співпадають
--        L(i, j) = max{L(i + 1, j), L(i, j – 1)}

-- але замість чисел ми можемо повертати рядки які виходять

-- в ідеалі запам'ятовувати обраховані значення використовуючи підхід динамічного програмування,
-- але в рамках обмеенного часу я не встиг це зробити


lps :: Eq a => [a] -> Int -> Int -> [a]
lps seq i j
  | i == j = [seq !! i]
  | seq !! i == seq !! j && i + 1 == j = [seq !! i, seq !! j]
  | seq !! i == seq !! j = seq !! i : lps seq (i + 1) (j - 1) ++ [seq !! j]
  | otherwise =
    let left = lps seq i (j - 1)
        right = lps seq (i + 1) j
    in if length left >= length right then left else right

main :: IO ()
main = do
    putStrLn "Enter string: "
    input <- getLine
    let n = length input
        result = lps input 0 (n - 1)

    putStrLn $ "Answer: " ++ show result
